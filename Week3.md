------------------

<br>

# Chapter 02. 컴퓨터의 발전과 성능

<br>

### 컴퓨터의 세대별 발전

<br>

#### 컴퓨터의 세대별 특징

| 세대 및 시기 | 주요 소자 | 기억 장치 | 특징 |
|:---:|:---:|:---:|:---:|
|`0세대 컴퓨터(1세대 이전)`|`기계적 릴레이`|`금속 기어, 카드`|`전자식 컴퓨터보다는 기계식 컴퓨터에 가까움`|
|`1세대 컴퓨터(~1950년대 후반)`|`진공관(전구)`|`자기드럼`|`전자식 컴퓨터화 됨. 하드웨어 개발에 중점. 무게가 크고 전력 소모가 많음`|
|`2세대 컴퓨터(~1960년대 초반)`|`트랜지스터, 다이오드`|`자기코어`|`고급 언어(Fortran, Cobol, Algol..) 등장`|
|`3세대 컴퓨터(~1970년대 중반)`|`SSI, MSI`|`RAM, ROM`|`IC회로 사용 시작. 현재의 컴퓨터와 유사함. OS개발, 다중 프로그래밍, 고급언어 활용`|
|`4세대 컴퓨터(~2000년대)`|`LSI, VLSI`|`SRAM, DRAM`|`객체지향언어 사용, PC등장, 병렬 처리 기능 강화`|
|`5세대 컴퓨터(2000년대 중반~)`|`VLSI, ULSI, GLSI, SoC`|`SDRAM, DRAM, flash`|`비노이만 구조 추구(양자컴퓨팅), 멀티코어 사용, 유비쿼터스 환경`|

> **IC회로란?** Integrated Circuit의 약자. 집적 회로: 전자 회로의 집합    
> **SSI?** Small Scale Integration     
> **MSI?** Medium Scale Integration    
> **LSI?** Large Scale Integration     
> **VLSI?** Very Large Scale Integration    
> **SoC?** System on Chip    

<br>

### 현대 컴퓨터 발전의 지표

###### 이번 주는 잠깐 대면 수업!

<br>

*대체로 다음 과정을 거쳐서 연산이 수행된다.*   

우리가 고급 언어로 프로그램을 작성하면, 컴파일러 또는 인터프리터가 저급 언어로 번역해주고, 실행 파일까지 만들어 준다. 결과물은 binary file 형태로 RAM위에 적재되고, RAM에 적재된 데이터는 CPU로 fetch(인출)된다.   

<br>

#### 폰노이만 아키텍쳐
   
현대 컴퓨터가 탄생하는 데 많은 과학자들이 기여했지만, 특히 **앨런 튜링의 유니버셜 기계 모델**을 설계하는데 가장 큰 기여를 했다. **폰 노이만은 유니버셜 기계 모델을 실제 하드웨어로 구체화 시킨 사람**이다.    

폰 노이만은 `프로그램 내장식 컴퓨터(프린스턴 아키텍쳐)` 모델을 제안했다. 이 모델의 특징은 프로그램을 저장하고 변경하는 것이 가능했는데, 이 때 소프트웨어의 개념이 처음 등장했다.    

`프로그램 내장식 컴퓨터`가 제안되기 이전에는 `고정결선식 프로그램 컴퓨터` 방식을 사용했었다. 고정결선식은 하드웨어가 구성된 방식을 벗어나는 연산을 수행할 수 없었다.    

폰 노이만 모델을 다음과 같이 수정해서 개선 시킨 모델이 `하버드 아키텍쳐`이다.    
* 메모리를 두 개로 분할하여 명령어와 데이터를 별도의 메모리에 저장    
* CPU의 제어장치와 연산장치를 별도의 버스로 각각 연결하여 명령어와 데이터를 병렬로 인출    

예를 들어, `Add r1 r2 r3`와 같이 3주소 방식의 명령이 있을 때,     
`Add`와 ` r1 r2 r3`로 하나의 명령을 '명령어(I)'와 '데이터(D)'로 구분해서 입력받는 방식이다.    

교재 p.63> 폰 노이만 병목 구간은 CPU와 메모리의 처리 속도 차이때문에 발생한다.    

<br>

#### 무어의 법칙

`무어의 법칙`은 경험적 관찰에 의해 예측한 것으로, 단일 마이크로칩에 포함된 트랜지스터의 수가 18개월마다 약 2배씩 증가한다는 것을 의미한다. 하지만 이미 반도체 집적 기술이 한계에 도달했기 때문에 무어의 법칙을 유지하기 어려울 것이라는 전문가들의 판단이 지배적이다. 이를 `무어의 벽`이라고 한다.

<br>

### 컴퓨터의 성능

<br>

#### 성능의 정의

순수 CPU의 실행시간으로 컴퓨터의 성능을 판단한다.      
* 프로그램을 수행하는 데 순수하게 사용된 시간     
* 입출력이나 다른 프로그램의 실행 시간이 포함되지 않는다.    

![컴퓨터의 성능](https://latex.codecogs.com/gif.latex?Computer%5C%20Performance%3D%7B1%20%5Cover%20CPU%20execution%5C%20time%7D)    

따라서, 컴퓨터의 성능은 CPU의 실행 시간이 짧을 수록 성능이 좋다고 판단한다.    

ex) M1와 M2의 성능 비교를 해보자.    
* M2는 M1보다 성능이 n배 좋다.    
* M1에 대해 M2의 성능 향상은 n이다.    
* M1에 대한 M2의 성능 비율은 n이다.    
     
M1에 대한 M2의 성능 비율    
= n    
= M2의 성능 / M1의 성능    
= M1의 실행시간 / M2의 실행시간    

<br>

#### 암달의 법칙

처리 속도를 상한선까지 개선하는 것이 목적이다.   

1. 시스템 중 개선이 가능한 일부분을 `f`라고 가정한다. `f`를 병렬화 해서 `n`배 성능 향상시키는 것이 목적이다.    
2. 시스템 전체가 `1`이라고 가정하면, 개선 불가능한 부분은 `1 - f` 이다. 순차 처리가 필요한 부분.     
3. M1을 기존 머신, M2를 개선한 머신이라고 가정한다.    

<br>

> s: 시스템 전체의 성능 향상
> m: M1의 실행 시간
> 
> ![s](https://latex.codecogs.com/gif.latex?s%20%3D%20%7B1%20%5Cover%20%7B%7Bf%20%5Cover%20n%7D%20&plus;%20%281%20-%20f%29%7D%7D)    
>
> 성능 개선이 없다면 n이 1이 된다.
> 
> <br>
>      
> 만약 n이 양의 극한값을 가지게 된다면, 즉 무한히 성능을 향상시킬 수 있다면,
> n에 양의 무한대 값을 대입해서 ![gif](https://latex.codecogs.com/gif.latex?f%20%5Cover%20n) 값을 0으로 수렴시킬 수 있다.
> 그러면 다음 수식을 만족한다.
> 
> ![gif](https://latex.codecogs.com/gif.latex?s%20%3D%20%7B1%20%5Cover%20%7B%7Bf%20%5Cover%20n%7D%20&plus;%20%281%20-%20f%29%7D%7D%20%5Cleq%20%7B1%20%5Cover%20%7B1%20-%20f%7D%7D)    
>
> <br>
> 
> 교재에 나온 예시를 위 식을 통해 해결해보자.
> 조건은 다음과 같다.
> * 하나의 프로그램이 싱글코어 프로세서를 사용하면 20시간 소요된다.
> * 이 프로그램에서 1시간 소요되는 부분은 병렬화할 수 없고, 나머지 19시간 소요되는 부분은 병렬화할 수 있다.
> * 병렬화된 부분을 처리하는 데 사용되는 프로세서의 수에는 제한이 없다.(물리적으로는 불가능하지만 논리적으로는 가능한 전제)
> 
> 위 식을 살펴보면, ![gif](https://latex.codecogs.com/gif.latex?f%20%5Cover%20n) 은 병렬화가 가능한 부분이고, ![gif](https://latex.codecogs.com/gif.latex?1%20-%20f) 는 병렬화(성능 개선)가 불가능한 부분이다.
> 
> <br>
> 
> Case1: 싱글 코어라고 가정하면, ![gif](https://latex.codecogs.com/gif.latex?f%20%5Cover%20n)가 19시간이 소요되고, ![gif](https://latex.codecogs.com/gif.latex?1%20-%20f) 는 1시간이 소요된다.
> 따라서 시스템 전체 성능 향상 s 는 ![gif](https://latex.codecogs.com/gif.latex?1%20%5Cover%2020) 이다.
>     
> Case2: 프로세서의 수가 무한대라고 가정하면, ![gif](https://latex.codecogs.com/gif.latex?f%20%5Cover%20n)는 0으로 수렴하고, ![gif](https://latex.codecogs.com/gif.latex?1%20-%20f) 는 여전히 1시간이 소요된다. 
> 따라서 시스템 전체 성능 향상 s 는 ![gif](https://latex.codecogs.com/gif.latex?1%20%5Cover%201) 로 1이다.
>     
> 결론은 최대 20배의 성능 향상이 발생할 수 있다.
> 
> 교재 p.71 예제 풀어보기!

<br>

#### CPU 성능 분석

