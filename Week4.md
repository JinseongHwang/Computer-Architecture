
<br>

#### 성능에 영향을 미치는 요소의 분석

<br>

|구분|명령어 개수|평균 CPI|클록 속도|
|:---:|:---:|:---:|:---:|
|`알고리즘`|O|||
|`명령어 집합 구조`|O|O|Δ|
|`컴퓨터 구현`||O|O|
|`컴퓨터 실현`|||O|

<br>

`명령어 개수 * 평균 CPI / 클록 속도 = CPU 실행시간`    
- 서로 영향을 미치는 구조로 되어있으므로, 실질적으로 CPU 성능을 좋게 하려면, 명령어 개수와 평균 CPI는 낮추고 클록 속도를 높이면 된다. 왜냐하면 CPU 실행 시간이 작을수록 성능이 좋은 것이기 때문이다.    

- 명령어 개수가 1개라고 가정했을 때,  CPU의 실행 시간은 `평균 CPI / 클록 속도`이다. 클록 속도와 역수 관계에 있는 클록 사이클 시간으로 표현하면 `평균 CPI * 클록 사이클 시간`으로도 표현 가능하다. 따라서 클록 사이클 시간이 작아진다면 평균 CPI가 증가할 수 있다.

- 평균 CPI는 `사이클 개수 / 명령어 개수`인데, 사이클 개수는 거의 고정이므로, 평균 CPI를 낮추려면 명령어 개수를 증가시켜야 한다.   

- 따라서 CPU 성능을 향상시키기 위해서 `명령어 개수, 평균 CPI, 사이클 시간`을 모두 낮추는 것은 불가능하다. 그렇기 때문에 우리는 최적의 타협점을 찾아야한다. 

> **Trade-Off - 타협접 찾기**
> 
> - **명령어 개수** 
>   - 알고리즘: 간결한 알고리즘을 사용할 수록 명령어 개수가 감소한다.
>   - 아키텍쳐: 하나의 명령어가 수행하는 일이 많으면 프로그램 크기(명령어 개수)가 감소한다. CISC(Complex Instruction Set Computer)라고 표현한다. 반대는 RISC(Reduced...)이다. 각각 장단이 존재한다.
> - **평균 CPI(평균 사이클  개수)**
>    - 아키텍쳐: CISC가 기능이 많아서 사용하기 쉽지만 병목현상 발생 가능성이 커지고, 사이클 개수가 증가한다.
>   - 컴퓨터 구현: 파이프라인(데이터와 명령어가 전송되는 구조) 구축을 잘 하면 사이클 개수를 줄일 수 있다.
> - **클록 사이클 시간**
>   - 컴퓨터 구현: 데이터 경로(큰 영향), 명령어 경로 등 파이프 라인 구축
>   - 컴퓨터 실현: 반도체 생산 및 제조 기술

<br>

#### 벤치마크와 성능 척도

<br>

**벤치마크의 의미**

성능을 평가하기 위하여 작업 부하로 선택된 프로그램의 모음   
성능을 평가하는 기준, 잣대가 되는 부하(load)   
주로 SPEC(Standard Performance Evaluation Corporation) 벤치마크를 사용한다.   

**평가 척도**

어떤 부분을 평가할 것인지에 따라 척도가 다르다.   
- CPU를 위한 CPI, 클록 속도, MIPS, MFLOPS   
- SPECratio
- KLIPS(Kilo Logical Inference per second)
- 그러나 어떤 성능 척도도 MIPS와 MFLOPS처럼 컴퓨터 시스템의 공급자에 의해 왜곡되어 사용될 수 있다.

**IPS(Instruction per second)**
- 1초동안 수행한 명령어의 개수를 나타낸다.
- 하지만 현대에 들어서 연산 속도가 매우 빨라지다 보니, Million으로 나눈 값, 아래의 표현 방법을 더 많이 사용한다.

**MIPS(Million Instruction per second)**
- 단위시간, 즉 1초에 수행한 명령어 개수를 100만으로 나눈 값.
- `명령어 개수 / (실행시간 * 10^6) == 클록 속도 / (CPI * 10^6)`

**MFLOPS(Million Floating Point Operation per second)**
- 1초에 실행한 부동소수점 연산의 수를 100만으로 나눈 값.
- `부동 소수점 연산 개수 / (실행 시간 * 10^6)`
- MIPS보다는 비교척도로서는 가치가 떨어진다. 그러나 GPU의 비교척도로서는 많이 사용된다.

<br>

**교재 p.81 예제 2-4>**    
|연산의 종류|비율|CPI|
|:---:|:---:|:---:|
|산술.논리|40%|1|
|적재|20%|2|
|저장|12%|2|
|분기|28%|2|

> **조건 및 문제**  
> - 최적화 컴파일러를 사용하면 산술 및 논리 연산이 절반으로 감소  
> - CPU의 클록률(클록 속도)은 1.0GHz라고 가정  
> - 이 때 최적화 컴파일러를 사용하는 경우와 사용하지 않는 경우의 MIPS를 구해라.  

<br>

> **풀이**  
> - 평균 CPI를 먼저 구한다.  
> - `평균 CPI_unopt = 0.4 * 1 + 0.2 * 2 + 0.12 * 2 + 0.28 * 2 = 1.6`   
> - 평균 CPI_opt는 바로 구할 수 없다. 비율이기 때문에 '산술.논리'가 절반일 때, 다른 연산의 비율을 먼저 구하자.  
>   - 산술.논리: (0.4 / 2) / (0.2 + 0.2 + 0.12 + 0.28) = 0.25  
>   - 적재: (0.2) / (0.2 + 0.2 + 0.12 + 0.28) = 0.25  
>   - 저장: (0.12) / (0.2 + 0.2 + 0.12 + 0.28) = 0.15  
>   - 분기: (0.28) / (0.2 + 0.2 + 0.12 + 0.28) = 0.35  
> - `평균 CPI_opt = 0.25 * 1 + 0.25 * 2 + 0.15 * 2 + 0.35 * 2 = 1.75`   
> - `클록 속도 / (CPI * 10^6)` 식을 사용해서 연산한다. (1.0GHz == 1.0 * 10^9)   
> - MIPS_unopt = (1.0 * 10^9) / (1.6 * 10^6) = 625
> - MIPS_opt = (1.0 * 10^9) / (1.75 * 10^6) = 571.4285714
> - 결론적으로, 최적화 시키지 않은 경우가 더 좋은 성능을 보여주는데, 이는 최초 문제에서 주어진 예시값이 옳지 못한 예시였기 때문이다.

<br>

-------------------------

# Chapter 03. 명령어 집합

<br>

## 명령어 집합

<br>

### 명령어 집합 구조 및 설계

<br>

**명령어 집합이란?**
- 명령어는 CPU가 수행할 동작을 2진코드로 정의한 것이다. 하지만 우리는 2진 코드를 작성할 수 없기 때문에 어셈블리어로 작성한다.
- 명령어는 컴퓨터 하드웨어 혹은 마이크로 프로그램에서 인식되거나 실행될 수 있는 기계 명령어(2진 코드)이다.
- 특정 CPU를 위해 정의된 명령어의 모음이다.
- 명령어 집합 구조(Instruction Set Architecture)는 좁은 의미의 컴퓨터 구조이다.
- 우리가 사용하는 프로그램과, 그 프로그램을 수행할 컴퓨터 하드웨어 사이의 인터페이스 간의 완전한 정의 혹은 명세이다. 즉 사용자와 하드웨어 사이 과정을 완전하게 정의 또는 명세해놓은 것이 명령어 집합이다.

<br>

**명령어가 공통으로 포함하는 정보**
1. 어떤 연산을 하고, 어떤 데이터를 다루는지,
2. 데이터 표현 방식(data type)
3. 데이터의 위치에 대한 정보를 알려주는 주소 지정 방식

<br>

**명령어 집합 설계**
- 하드웨어 기술이나 컴퓨터의 구성, 프로그래밍 언어, 컴파일러 기술, 플랫폼이 될 운영체제 등을 고려해야 하는 매우 어려운 작업이다.

> - 설계 논점
>   - 연산의 종류: 명령어가 수행 가능한 일의 종류(4가지: 전송, 처리, 제어, 입출력)
>   - 데이터 형식: 데이터로 가능한 값인지, 데이터의 의미가 뭔지, 데이터 저장 방식 ...
>   - 명령어 형식: 명령어 구성, 구분하는 부분. 연산 종류를 명시하는 연산 부호(op code)
>   - 피연산자를 위한 주소지정방식: 연산 종류에 따라 피연산자가 필요하다. 나중에 자세히 알아보자.

<br>

## 명령어의 특성

 - 명령어의 구성
   - 연산 부호: 연산 종류를 설정한다.
   - 피연산자 필드: 연산될 데이터 정보이다. 데이터가 어디에 저장되어 있는가?
   - 모드 비트: CISC에서 주로 사용된다.(직접 주소, 간접 주소) RISC에서는 사용하지 않는다.
   - 다음 명령어 주소 필드: 다음 명령어 위치를 나타내는데 사용한다. RISC에서는 사용하지 않는다.

<br>

 - 명령어 길이
    - 고정 길이: 명령어 길이가 일정(종류, 구성요소..에 상관없이)하다. 다음 명령어 주소 필드가 없어도 된다. 따라서 해석기 H/W가 단순해진다. 길이가 정해져있기 때문에, 메모리의 작은 공간에 채워 넣는 행위가 안된다.
    - 가변 길이: 명령어 길이가 가변적이다. 다양한 길이를 가지고 있다. 메모리를 절약할 수 있는 장점이 있다. 프로세스 설계 난이도가 올라가고, 해석기가 복잡해지고, 다음 명령어 주소를 저장하는 필드가 반드시 필요하다.

<br>

### 피연산자의 수

<br>

무항, 단항, 이항, 삼항까지는 C언어 코딩을 하며 써본적이 있다.
다항 피연산자를 사용하는 경우는 어셈블리에서 CISC의 경우에만 존재한다.

1. **일반적인 함수 유형: `z = f(x, y)`**: 대표적인 3주소 방식(f: 명령어, x y z: 피연산자)
2. 근원지 피연산자 중 하나를 목적지 피연산자와 겸용: `z = f(x, z)`: 2주소 방식
3. 메모리 주소 대신 레지스터 주소 사용: 
    - 메모리의 용량은 레지스터의 용량보다 매우 크다.(RAM vs Register)
    - 완전한 메모리 주소는 bit 수가 많이 필요하다.
    - 레지스터 사용시 bit가 매우 적음. 용량 제한이 있기때문에 데이터 숫자를 동시에 256개 까지만 저장할 수 있다.
    - 메모리를 사용하면 주소가 길어지고 많은 양 처리 가능, 레지스터를 사용하면 주소가 짧아지고 적은 양만 처리 가능.
4. 묵시적 피연산자 사용: `Acc = f(Acc, x)`: 1주소 방식(Accumulator: 누산기)
5. 스택 사용: TOS(Top of Stack) 0주소 방식: 데이터가 스택에 있어서 주소 명시가 필요없다.

> 왜 이걸 0주소, 1주소, 2주소, 3주소.. 나누는가?
> - 명령어 길이를 조금이라도 줄이고싶어서!

<br>

## CPU의 기본 구성과 가상 명령어 집합

<br>

### CPU의 기본 구성과 명령어의 실행 순서

<br>

- CPU는 명령어 해석, 실행, 범용 연산을 수행하는 ALU로 구성된다.
- CPU는 명령어와 데이터 등을 위해 여러 종류의 레지스터를 사용한다.

p.96 폰 노이만 모델을 살펴보자.

- PC(Program Counter 계수기): 다음에 실행할 명령어의 '주소'를 보관하는 레지스터이다. 명령어를 인출한 후 명령어 길이만큼 증가한다.
- IR(Instruction Register 명령어 레지스터): 가장 최근에 인출한 명령어를 저장하는 레지스터이다.
- ACC(Accumulator 누산기): 계산 결과를 일시적으로 보관하는 레지스터이다.
- MAR(Memory Address Register): 프로세서가 메모리에 접근하기 위해 참조하려는 데이터의 '주소'를 보관하는 레지스터
- MBR or MDR(Memory Buffer(Data) Register): 프로세서가 메모리로부터 읽거나 또는 메모리에 저장할 데이터 자체를 보관하는 버퍼이다.

<br>

*CPU 중심으로 단어들을 서술한다.*

1. 적재과정(메모리 -> CPU): `load`: CPU가 메모리에 있는 데이터를 읽어오는 것
2. 저장과정(CPU -> 메모리): `store`: CPU가 메모리에 데이터를 기록하는 것

<br>

**명령어 (부)사이클**

1. 인출 사이클: 실행할 명령어를 CPU로 가져오는 과정이다.
2. 실행 사이클: 인출한 명령어에 포함된 연산부호가 의미하는 연산을 수행한다.
3. 간접 사이클: 간접 주소 방식에서 데이터의 실제 주소를 읽어온다.
4. 인터럽트 사이클: 인터럽트 처리를 한다.

> 인출 사이클보다 실행 사이클의 작업량이 매우 많아, 오늘날 컴퓨터는 실행 사이클을 다수의 단계로 분할한다.

<br>

**메모리에 있는 데이터를 프로세서가 읽어들이는 과정(적재)**

1. 프로세서는 데이터가 있는 메모리의 주소를 MAR에 보냄.
2. MAR이 지시하는 메모리 주소에 있는 데이터를 읽어와서 MBR에 저장.
3. 프로세서는 MBR에 저장된 데이터를 읽는다.

**프로세서가 처리한 데이터를 메모리에 저장하는 과정(저장)**

1. 프로세서는 데이터를 저장할 주소를 MAR에 보낸다.
2. 프로세서는 실제 데이터를 MBR에 보낸다.
3. 메모리는 MAR이 지정하는 위치에 따라 MBR의 내용을 저장한다.

**인출 사이클**

1. PC가 가리키는 메모리 주소를 MAR에 보낸다.
2. 메모리에서 MAR이 지시하는 메모리 내용인 명령어를 MBR로 보낸다.
3. MBR에 있는 명령어를 IR로 가져온다.
4. **(중요)다음 명령어를 가리키는 PC의 내용을 갱신한다.**
