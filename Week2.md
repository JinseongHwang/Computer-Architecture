### 운영체제와 부팅

<br>

#### 운영체제란?
간단하게 알아보면, 다음과 같은 역할을 수행하는 소프트웨어이다.
* 컴퓨터 시스템의 하드웨어 자원 관리
* 사용자와 하드웨어 사이의 인터페이스 역할
* 하드웨어의 고장 탐색, 오류 처리, 보안 유지   

#### 부팅이란?
1. 컴퓨터에 전원을 켜고 운영체제를 올리는 과정   
2. 보조기억장치(HDD, SSD)에 저장된 운영체제를 메인 메모리(RAM)에 불러들이는 과정   
3. 부트 스트랩 로더, IPL 등을 사용한다.   
   
#### 필요성
1. 모든 s/w는 h/w에서 동작하려면 메인 메모리에 적재(load) 되어야함.   
2. RAM은 전원 인가를 하면 비어있음.   
즉, OS가 RAM에 적재되지 않았으므로 컴퓨터가 켜져도 OS가 h/w에서 실행될 수 없음. -> 부팅과정이 필요함   
   
#### 부팅과정(예전 방식)
1. ROM 형태의 특수저장장치에 부트(스트랩)로더가 저장되어 있다.   
이는 HDD에 저장된 OS를 RAM에 단계적으로 저장하는 소규모 프로그램이다.   
이는 펌웨어 적 성격을 띄고 있다. 하드웨어 화 된 소프트웨어인것이다.
컴퓨터에 전원을 인가하면 먼저 부트로더가 실행된다.   
2. 부트로더는 HDD위에 운영체제가 어디에 저장되어 있는지 알고있다.   
운영체제 커널을 찾아서 RAM에 적재시킨다.   
`>> 커널은 간단히 말해, 운영체제 사용에 필수적인 특정한 일부분이다.`   
3. 부트로더를 통해 HDD에 있는 운영체제 커널이 RAM으로 적재가 완료되었다면,   
부트로드는 h/w 제어 권한을 RAM 위에 있는 운영체제에게 전달한다.    

#### 부팅과정(요즘 방식)
1. 컴퓨터에 전원을 인가하면 컴퓨터는 BIOS를 기동한다.   
2. BIOS는 h/w에 이상이 없는지 확인한다.   
3. 이전에 이상이 없다고 판단되면, BIOS는 부팅 매체인 HDD에 저장된 부트로더를 메인 메모리로 적재한다. 그리고 h/w의 제어 권한을 부트로더에게 전달한다.   
4. 부트로더는 BIOS를 종료한다.   
5. HDD의 OS를 메인 메모리에 적재한다.   
6. 부트로더가 OS로 제어 권한을 전달한다.   

<br>

> **왜 부팅 과정에 변화가 생긴걸까?**   
> 1. 이전의 방식으로는 멀티부팅이 불가능했다.   
> 부트로더가 그저 HDD에 저장된 운영체제 커널의 주소만 전달했기 때문인데,   
> 2. 요즘 방식을 따라가보면, 부트로더가 BIOS에 의해 HDD위로 적재된다.   
> 하나의 HDD위에 여러 개의 OS가 설치되어 있다고 가정하면, 여러 개의 부트로더가 HDD위에 적재되는 것이다.    
> 그러면 각각의 OS의 커널이 각각의 다른 주소를 가지고 있다.   
> 여러 OS의 주소는 MBR(Master Boot Record)의 통제를 받아서 하나의 OS 커널이 RAM으로 적재되는 것이다.

<br><br>

### 컴파일러와 인터프리터

<br>

컴파일러와 인터프리터의 공통점은 둘 다 번역기이다.   
고급 언어(C, C++, Java..)들을 저급 언어(어셈블리어)로 번역하는 역할이다.   
<br>

> #### 어셈블리어가 필요한 경우?
> 1. 실행 속도와 메모리 제한이 매우 중요한 프로그램
> 2. 속도가 매우 중요한 프로그램의 일부분(C 또는 C++ 중간에 어셈블리로 작성)
> 3. 오래된 컴퓨터나 특수한 컴퓨터(아두이노)에 사용되는 프로그램
> 4. 프로세서의 동작 모드를 바꿀 필요가 있는 프로그램

<br>

#### 컴파일러란?

컴파일러는 고급 언어로 작성된 원시 프로그램을 저급 언어로 구성된 목적 프로그램으로 변환하는 소프트웨어이다. 즉, 컴파일러의 입력은 원시 프로그램(.c, .cpp, .cs, .java..)이고, 출력은 목적 프로그램(.obj, .class..)이다.   

1. 고급 언어로 작성된 프로그램
2. 프로그램 소스코드 **전체** 를 컴파일러가 저급 언어로 변환
3. 프로그램 실행   
   
컴파일러는 정적 바인딩(static binding) 또는 사전 바인딩(early binding) 방식을 사용하므로, 데이터 형식이 고정된 프로그램에서 사용 가능하다. 예를 들면, C언어 같이 변수 선언 시에 int, double, char 등과 같이 데이터 형식이 정해지면 가능하다. 하지만 javascript 처럼 변수 선언 시에 var(~ ES5), let(ES6 ~) 처럼 변수라는 것만 알 수 있고 무슨 타입인지 알 수 없다면 사용 불가능하다.    

<br>

#### 인터프리터란?

인터프리터는 고급 언어에서 하나의 명령어를 분석하여 동일한 기능을 수행하는 저급 언어 명령어로 변환한 후 저급 언어 명령어를 실행시키며, 전체 프로그램이 실행될 때 까지 이 과정을 반복하는 소프트웨어이다.   

1. 고급 언어 프로그램 **명령어 1개(또는 1줄)**
2. 인터프리터가 저급언어로 변환
3. 프로그램 실행
4. 프로그램 전체를 실행 완료할 때 까지 1~3 반복   
    
인터프리터는 동적 바인딩(dynamic binding) 또는 사후 바인딩(late binding) 방식을 사용하기 때문에 데이터 형식이나 구조가 동적으로 결정되는 프로그램에서 사용된다.   

<br>

> **컴파일러와 인터프리터 비교**
> 컴파일시간: 컴파일러 > 인터프리터
> 실행시간: 컴파일러 < 인터프리터
>      
> *정리하자면,
> 사용 목적과 기능에 따라 장단점이 존재하는 것이지, 어느 쪽이 우수하다고 판단하기는 어려움.*   

<br>

### 컴퓨터의 분류

<br>

#### 처리 능력에 의한 분류

(개인용)태블릿 컴퓨터, 개인용 컴퓨터 / (다중)워크스테이션, 미니컴퓨터/메인컴퓨터, 슈퍼컴퓨터

#### 사용 목적에 의한 분류

전용 혹은 특수 목적 컴퓨터(ex 군사용, 의료용(MRI, MRA..), Playstation..), 범용 컴퓨터(다목적, 대부분)

#### 응용 분야에 의한 분류

데스크톱 컴퓨터, 서버 컴퓨터, 임베디드 컴퓨터(신호등, 레이저스캐너, 오실로스코프..)

#### 사용 데이터에 의한 분류

디지털 컴퓨터(불연속 자료의 조합), 아날로그 컴퓨터(전압, 전류, 온도... 연속적인 데이터)

<br><br>

### 컴퓨터 구조, 구성, 실현

<br>

**컴퓨터 구조**: (What)하드웨어와 소프트웨어의 인터페이스에 대한 설명을 의미하는 명령어 집합 구조    
> ex) 컴퓨터는 9 * 8 연산을 수행할 수 있다.

**컴퓨터 구성**: (How)아키텍쳐 사양에 대한 형체를 제공하는 논리적인 골격, 즉 CPU와 각종 구성 요소, 관련 회로의 인터페이스에 대한 세부사항   
> ex) 9 * 8 연산을 수행하는 데, 9 + 9 + ... + 9 방식으로 연산된다.

**컴퓨터 실현**: 컴퓨터 구현의 구체적인 버전으로, 어떤 컴퓨터 부품이 사용되며 그 부품들이 어떻게 서로 연결되고 배치되는지를 결정
> ex) 신기술이나 부품의 신뢰성, 유지보수, 냉각 방법, 패키징 방법..
   
**컴퓨터 계열**: 동일한 컴퓨터 구조를 사용하지만 다른 방식으로 시스템을 구현한 컴퓨터의 집합
> ex) IBM계열, Free BSD계열 ... h/w driver에 따른 s/w 호환성이 달라진다.

<br><br>

### 하드웨어와 소프트웨어 상호조정

<br>

예를 들어, 가산기를 만든다고 가정할 때.    
1. **Hardware (펌웨어, 전자회로 및 기계장치)**    
* 고비용, 고성능 -> 변경이 불가능하거나 힘들다.   

2. **S/W(응용 소프트웨어, 시스템 소프트웨어)**    
* 저비용, 높은 유연성 -> 속도가 h/w에 비해서 매우 느림

<br>

